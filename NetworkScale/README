%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Author: 	Robert J. Wagner
 Date: 		June 13th, 2024
 Description: README for the ensemble bond kinetics studies and their extended data from Sections 4-5 in "A foundational framework for the mesoscale modeling of dynamic elastomers and gels".
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONTENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 This directory contains the following src code written in MATLAB2022a:
	1. Main.m
		Purpose: MAIN script from which all others are automatically called
	2. DefineControlSwitches.m
		Purpose: Script in which USER sets which types of simulations are ran. This is where USER toggles switches to 0 (off) or 1 (on) to run specific study cases (e.g., chain length sweeps, frequency sweeps, etc.)
	3. DefineFolders.m 
		Purpose: Script where USER sets the directory paths in which to store inputs (e.g., .in files) and outputs (e.g., .dump and .mat files). USER must also set "Directories.storage_drive" on which large data sets are stored
	4. DefineparameterPackage.m 
		Purpose: Script wherein the case-specific parameters such as chain lengths, activation energies, packing fractions, loading rates, etc. are prescribed.
	5. InitiateRunCompile.m 
		Purpose: Loops over the network generation procedure (via GenerateTopology.m); simulation execution (if not set up for running on an external HPC source, e.g., Stampede3) (via RunSimulation.m); and data compilation and output computation procedures (via CompileData.m), for each of the two model types (Bead-spring, <ModelType=0> or Mesoscale, <ModelType=1>).
		A. GenerateTopology.m 
			Purpose: Generates the initial configuration of each simulation and then prints the input files (.in) called out by LAMMPS. These .in files also call out toplogy files (.txt) using the readdata command in LAMMPS. These topology files are also generated and saved by GenerateTopology.m.
		B. RunSimulation.m
			Purpose: Identifies the appropriate .in files for LAMMPS, and then executes LAMMPS call using the system(command) prompt in MATLAB. Also saves and relocates .dump files to specified output directory. 
		C. CompileData.m 
			Purpose: Intakes .dump files directly output from LAMMPS, parses the data (via ParseDumpFiles.m), and then compiles it into a useable format for PostProcess.m, as compressed MATLAB stuctures (.mat). Also computes pertinent outputs such as chain end-to-end vectors, forces, etc.
	6. PostProcessData.m 
		Purpose: Intakes the compiled .mat structures generated by CompileData.m, analyzes the data, and outputs plots for the manuscript into study-specific directories.

 A set of secondary functions are also included as desrcibed below. These functions require no USER intervention and are described for reference only.
	7. DefineFileNames.m
		Purpose: Automatically sets the filenames of pertinent inputs and outputs.
	8. DefineInputTimeScales.m
		Purpose: Automatically defines pertinent input frequencies (e.g., bond dynamic check frequency) and timescales (e.g., equilibration time, loading time, etc).
	9. DefineLoadingTimescale.m
		Purpose: Defines required duration of loading and number of loading steps based on loading rate, max stretch, etc.
	10. DefineMatlabNetworkInitiationInputs.m
		Purpose: Defines phenomenological inputs for the generation procedure of initial topologies using MATLAB.
	11. DefineNormalizedBindingEnergies.m
		Purpose: Defines the normalized binding energies based on input values of ka and kd.
	12. DefineNumbersOfTethersAndParticles.m
		Purpose: Defines the number of backbone crosslinks (tethers) and total numbe of particles for each model type. This algorithm is specific to the 5-branched side chain polymers described in Section 4 of the manuscript.
	13. DefineTimeScale.m
		Purpose: Sets the timescales of the model based on the monomer diffusion time, \tau0=b^2/D0, where b is Kuhn length and D0 is diffusion coefficient of a mer. Sets timesteps of model as dt = \tau0/dtFact. Also sets the damper, and timesteps.
	14. IdentifyFailedRuns.m
		Purpose: In case certain simulation samples did not converge due to stochastic instabilities, this algorithm will identify which cases do not have .dump files from LAMMPS and automatically set flags so that the code reruns RunSimulation.m for these simulations.
	15. IdentifyFailedCompiles.m
		Purpose: Similar to IdentifyFaliedRuns.m, in case certain simulation samples did not converge due to stochastic instabilities, this algorithm will identify which cases do not have compiled data and automatically set flags so that the code reruns CompileData.m for these simulations.
	16. ParseDumpFiles.m
		Purpose: This code is called out by Compile.m to parse the raw .dump files output by LAMMPS and store them in a more useable MATLAB structure (.mat) for analysis.
	17. PlotParameterSpace.m 
		Purpose: This stand-alone function plots the axes of the spatially and temporally related sweeping parameters detailed in the first figure of Section 4.
	18. PlotTimingCases.m 
		Purpose: In the event that Controls.RunTimingCase==1 (see DefineControlSwitches.m), this function is called out instead of PostProcess.m to generate the computational savings plots from Appendix I.
	19. UnpackParameters.m 
		Purpose: This function automatically unpacks the parameters compiled by DefineParametersPackage.m for call-out by subroutines within parameter sweeping loops.

		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RUN INSTRUCTIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 The following gives step-by-step instructions for running the code used to produce the results of Sections 4 and 5. We do not recommend modifying any inputs unless these instructions explicitly indicate to do so. USER needs only to correctly set directories and then interface with Main.m, DefineControlSwitches.m, and DefineFolders.m, as follows, in order to reproduce the results of the manuscript:

 1. Ensure that MATLAB2022a or later is properly installed
 2. Ensure that LAMMPS is properly installed per the instructions of INSTALL.txt in top-level folder
 3. Open Main.m
 4. From Main.m, open DefineControlSwitches.m 
 5. Set the work flow controls in DefineControlSwitches.m, based on following legend:
	A. <Controls.n_processors> - set to integer number of desired processors used for generating input scripts, compiling data, etc. For very large file sizes, recommended is 1.
	B. <Controls.GenerateTopologies> - set 1 (on) to generate topology and input files, and 0 (off) to skip. Will automatically skip this step if the relevant files already exists and Controls.OverrideTopologies~=1 and Controls.OverrideInputScripts~=1.
	C. <Controls.RunSimulations> - set 1 (on) to run LAMMPS simulations and produce .dump files using RunSimulation.m, and 0 (off) to skip. Will automatically skip this step if the .dump files or compiled .mat files already exists and Controls.OverrideRun~=1. Note, if the option, Controls.PrepareForStampede==1, this indicates that the input files (.in) files for LAMMPS are configured to run on the HPC cluster, Stampede3, and the code will not attempt to run the LAMMPS simulations on the local hardware. Thus, set <Controls.OverrideForStampede = 0> after line 112 to make sure the simulations are run locally.
	D. <Controls.CompileData> - set 1 (on) to parse the data and compute outputs using CompileData.m, and 0 (off) to skip. Will automatically skip this step if the compiled .mat files already exists unless Controls.OverrideCompile==1 (in which case it will rerun the parsing process) and/or Controls.OverrideCompute==1 (in which case it will rerun the output computation process while skipping the data parsing process).
	E. <Controls.PostProcess> - set 1 (on) to analyze the data and plot the outputs for the manuscript via PostProcess.m, and 0 (off) to skip. Will automatically skip this step if the compiled output files already exists unless Controls.PostProcess==1.	
 	F. <Controls.RerunFailed> - set 1 (on) check whether any runs failed due to stochastic instabilities. If any failed, the data generation process and simulation run will be executed again for the failed cases. Set 0 (off) to skip. Recommended is to leave this set to 0.	
  	G. <Controls.RecompileFailed> - Companion to <Controls.RerunFailed> for solely recompiling data. Set 1 (on) check whether any compiles of failed runs must be re-executred. If any failed, the data parsing and output computation processes will be rerun. Set 0 (off) to skip. Recommended is to leave this set to 0.	
   	H. <Controls.LinearOrLangevin> - Set 0 for linear springs and 1 for Langeving springs in the mesoscale model. Leave <Controls.LinearOrLangevin = 1>, based on findings of manuscript.	
   	I. <Controls.ToggleDynamics> - Set 0 to toggle off dynamics and 1 to turn them on. Leave <Controls.ToggleDynamics = 1>.	 
 6. Within DefineControlSwitches.m, set only one of the following toggles to 1 in order to prescribe what type of parameter sweep will be conducted. If none of these are set to 0, the default parameter sweep from Section 4's second figure will be executed (phi={0.2,0.5}, kd={0,0.1}/\tau_0, \dot \varepsilon={0.01,0.1}/tau_0, N={12,36}).
	A. <Controls.RunChainLengthSweep> - set 1 (on) to run sweep over chain lengths via N={12,18,24,30,36} while \dot \varepsilon = 0.01/\tau_0, kd = 0, and phi = 0.2.
	B. <Controls.RunLoadingRateSweep> - set 1 (on) to run sweep over loading rates via \dot \varepsilon={0.01,0.02,0.03,0.06,0.1}/tau_0 while kd=0, phi=0.2, N=12.
	C. <Controls.RunDetachmentRateSweep> - set 1 (on) to run sweep over detachment rates via k_d={0,0.001,0.003,0.01,0.03,0.1}/tau_0 while \dot \varepsilon=0.01/\tau_0, phi=0.2, N=12.	
	D. <Controls.RunTimingCase> - set 1 (on) to compare CPU time for runs with k_d=0.01/tau_0 while \dot \varepsilon=0.01/\tau_0, phi=0.2, N=12.		
	E. <Controls.RunOscillatory> - set 1 (on) to run a frequency sweep at 17 distinct frequencies (see DefineparameterPackage.m) when phi=0.2, N=12, and k_d is swept over k_d={1e-4,1e-3,1e-2}1/tau_0.	
	F. <Controls.RunLargeDeformation> - set 1 (on) to run a large domain simulation (Np=5e3 polymers) to a uniaxial stretch of 20 when phi=0.2, N=12, k_d = 0.01/\tau_0 and the loading rate is swept over \dot \varepsilon = {0.125, 0.25, 0.5, 1} k_d.	
	G. <Controls.PrepareForStampede> - set 1 (on) to prepare the input scripts (.in) for running on an external HPC resource Stampede3. Refer to the .bash files for how the directories must be named and input scripts must be stored. Set this to 0 to run on the local machine.
	H. <Controls.RunTheLJCase> - set 1 (on) to run a sample bead-spring simulation with and without the LJ potential to gauge the change in stress.
 7. Skip to line 155 and set the following switches to 1 (on) or 0 (off) in order to prescribe what is calculated during the CompileData.m execution:
	A. <Controls.CalcuateStress> - set 1 (on) to calculate the virial stress of the network run (recommend leaving on for all cases, otherwise PostProcess.m will not function properly)
	B. <Controls.CalculateEndtoEnd> - set 1 (on) to calculate the end-to-end vector distribution of the network respect to time during loading and stress relaxation. This will automatically occur if the network stress is computed via <Controls.CalcuateStress==1>
	C. <Controls.CalculateMSD> - set 1 (on) to calculate the mean-square displacements of both tethers and stickers  with respect to time during equilibration.
	D. <Controls.CalculateBondKinetics> - set 1 (on) to calculate the average attachment and detachment rates, as well as  attached/detached fractions with respect to time during equilibration.
	E. <Controls.CalculateAlignment> - set 1 (on) to calculate the average covariance matrix components for chain end-to-end vectors (\sum r \otimes r), with respect to time during loading and stress relaxation.
	F. <Controls.ComputeNetworkScale> - set 1 (on) to calculate stress using the mesh-scale virial formulation, rather than Kuhn length scale formulation, for the bead spring model during loading and stress relaxation. Recommended that this is kept as 1 to reduce noise.
	G. <Controls.CalculateClusteringMetrics> - set 1 (on) to calcualte the degree of inter- versus intra-molecular bonds during equilibration. 	
	H. <Controls.MakeMovieDuringCompute> - set 1 (on) to use MATLAB to make a movie of the networks undergoing deformation throughout the entire loading history. For bead-spring, it will show only the end-to-end vectors of the overal chains (not Kuhn segments), which is not a capability of Ovito. This was done to visually compare bead-spring versus mesoscale models on a one-to-one basis, although the findings were not telling, and are not reported in the manuscript. Recommend leaving this set to 0 to skip MATLAB movie plotting and expedite output computation. Better option is to use OVITO for visualization.	
 8. Skip to line 193 and set the override switches as follows:
	A. <Controls.OverrideTopologies> - set 1 to overwrite input files
	B. <Controls.OverrideInputScripts> - set 1 to specifically overwrite the .in files for LAMMPS without regenerating initial chain/network topologies
	C. <Controls.OverrideRun> - set 1 to overwrite LAMMPS .dump files by reruning the LAMMPS simulations
	D. <Controls.OverrideCompile> - set 1 to overwrite the compiled .mat strutures generated by parsing the raw .dump files from LAMMPS using CompileData.m 
	E. <Controls.OverrideCompute> - set 1 to overwrite the computed values from CompileData.m without also re-parsing and regenerating the compressed .mat files from CompileData.m
 	F. <Controls.OverrideStorageLoss> - set 1 to overwrite the storeage and loss data in the event that <Controls.RunOscillatory==1> (does nothing otherwise).
 	G. <Controls.OverrideConsolidate> - set 1 to overwrite a data consolidation procedure that takes place during PostProcess.m
 	H. <Controls.OverridePostProces> - set 1 to overwrite the output plots
 	I. <Controls.OverrideMovie> - set 1 to overwrite the movies that are generated in the event that <Controls.MakeMovieDuringCompute==1> (does nothing otherwise)
 9. Open DefineFolders.m and set:
	A. <current_dir> to the current directory in which this src code is stored. This should be done automatically. Input files will be stored in this current directory, as will output plots. 
	B. <current_dir_lmp> to the equivalent directory as <current_dir>, but formatted for WSL's LINUX mount
	C. <output_dir> to the desired output folder for .dump and .mat files. Recommend doing this on an internal SSD with at least 2-4 TB of storage.
	D. <lmp_path> as path to LAMMPS executable (e.g., 'lmp', or 'lmp_mpi'). Make sure to use WSL compatible formatting in the directory syntax, (e.g., 'mnt/c/Users/...' instead of 'C:/Users/...'), if using WSL.
 10. Run Main.m
 
Note: To use the raw data files generated for this manuscript, move the raw .dump files to the location of the 'OutputDir' and compiled .mat files to the location of 'CompiledFolderName' as defined in 'DefinFolders.m > DefineSubDirectories' lines 132 (Input data), 145 (raw .dump files from LAMMPS), 154 (compiled .mat folders from CompileData.m). Make sure all files are unzipped. Data compilation via CompileData.m and post-processing via PostProcessData.m may occur upon running Main.m.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OUTPUTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 This src code will generate the raw plots used in Appendix F of the manuscript. Plots used in the main manuscript are stored in the subdirectories of '/Polished Plots/' for each study type. For all plots, discrete points with error bars represent data from the bead-spring model while continuous curves with shaded error regions represent mesocale model data. The subdirectories are organized as follows:
 
 1. '/Polished Plots/Overall Sweep/' contains the plots for the initial, overall parameter sweep of Section 4, in which \phi, N, k_d, and \dot \varepsilon are each swept over two values. Purple data in these plots represent \phi=0.5 while balck data represent \phi=0.2. The filenames indicate N, k_d and \dot \varepsilon via W={\dot \varepsilon}/{k_d}. 
 
 2. '/Polished Plots/Length Sweep/' contains the plots for the chain length sweep of Section 4.1. Green data represents N=12, while black data represents N=36. The filenames indicate \phi, k_d, and \dot \varepsilon via W={\dot \varepsilon}/{k_d}. 
 
 3. '/Polished Plots/Loading Rate Sweep/' contains the plots for the loading rate sweep of Section 4.2. Black data represents \dot \varepsilon = 0.01/\tau_0, while orange data represents \dot \varepsilon = 0.1/\tau_0. The filenames indicate \phi, k_d, and N. 
 
 4. '/Polished Plots/Detachment Rate Sweep/' contains the plots for the detachment rate sweep of Section 4.3. Black data represents k_d = 0, while red data represents k_d = 0.1/\tau_0. The filenames indicate N, \phi and \dot \varepsilon via W={\dot \varepsilon}/{k_d}.  
 
 5. '/Polished Plots/Large Deformation/' contains the plots for the loading rate sweep of large deformation to an RVE stretch of 20 in Section 5. Black data represents W = {\dot \varepsilon}/{k_d}=0.125, while orange data represents W = {\dot \varepsilon}/{k_d}=1. The filenames indicate N, \phi and k_d. 
 
 7. '/Polished Plots/LJ Study/' contains plots comparing the bead-spring stress data with (closed circles) and without (open circles) the LJ potential representing excluded volume effects. Mesoscale data is also shown for comparison. Black data represents \phi=0.2, while purple data represents \phi=0.5. The filenames indicate N, \phi and \dot \varepsilon via W={\dot \varepsilon}/{k_d}.   
	
